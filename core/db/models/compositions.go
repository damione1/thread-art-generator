// Code generated by SQLBoiler 4.18.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Composition is an object representing the database table.
type Composition struct {
	ID    string `boil:"id" json:"id" toml:"id" yaml:"id"`
	ArtID string `boil:"art_id" json:"art_id" toml:"art_id" yaml:"art_id"`
	// Current status of the composition processing
	Status CompositionStatusEnum `boil:"status" json:"status" toml:"status" yaml:"status"`
	// Number of nails to use in the circle
	NailsQuantity int `boil:"nails_quantity" json:"nails_quantity" toml:"nails_quantity" yaml:"nails_quantity"`
	// Image size in pixels
	ImgSize int `boil:"img_size" json:"img_size" toml:"img_size" yaml:"img_size"`
	// Maximum number of paths to generate
	MaxPaths int `boil:"max_paths" json:"max_paths" toml:"max_paths" yaml:"max_paths"`
	// Starting nail position
	StartingNail int `boil:"starting_nail" json:"starting_nail" toml:"starting_nail" yaml:"starting_nail"`
	// Minimum difference between connected nails
	MinimumDifference int `boil:"minimum_difference" json:"minimum_difference" toml:"minimum_difference" yaml:"minimum_difference"`
	// Brightness factor for thread lines
	BrightnessFactor int `boil:"brightness_factor" json:"brightness_factor" toml:"brightness_factor" yaml:"brightness_factor"`
	// Image contrast adjustment value
	ImageContrast float64 `boil:"image_contrast" json:"image_contrast" toml:"image_contrast" yaml:"image_contrast"`
	// Physical radius of the final artwork in mm
	PhysicalRadius float64 `boil:"physical_radius" json:"physical_radius" toml:"physical_radius" yaml:"physical_radius"`
	// URL to the preview image of the composition result
	PreviewURL null.String `boil:"preview_url" json:"preview_url,omitempty" toml:"preview_url" yaml:"preview_url,omitempty"`
	// URL to download the GCode file
	GcodeURL null.String `boil:"gcode_url" json:"gcode_url,omitempty" toml:"gcode_url" yaml:"gcode_url,omitempty"`
	// URL to download the paths list file
	PathlistURL null.String `boil:"pathlist_url" json:"pathlist_url,omitempty" toml:"pathlist_url" yaml:"pathlist_url,omitempty"`
	// Thread length in meters
	ThreadLength null.Int `boil:"thread_length" json:"thread_length,omitempty" toml:"thread_length" yaml:"thread_length,omitempty"`
	// Total number of thread lines
	TotalLines null.Int `boil:"total_lines" json:"total_lines,omitempty" toml:"total_lines" yaml:"total_lines,omitempty"`
	// Error message if processing failed
	ErrorMessage null.String `boil:"error_message" json:"error_message,omitempty" toml:"error_message" yaml:"error_message,omitempty"`
	CreatedAt    time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt    time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`

	R *compositionR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L compositionL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CompositionColumns = struct {
	ID                string
	ArtID             string
	Status            string
	NailsQuantity     string
	ImgSize           string
	MaxPaths          string
	StartingNail      string
	MinimumDifference string
	BrightnessFactor  string
	ImageContrast     string
	PhysicalRadius    string
	PreviewURL        string
	GcodeURL          string
	PathlistURL       string
	ThreadLength      string
	TotalLines        string
	ErrorMessage      string
	CreatedAt         string
	UpdatedAt         string
}{
	ID:                "id",
	ArtID:             "art_id",
	Status:            "status",
	NailsQuantity:     "nails_quantity",
	ImgSize:           "img_size",
	MaxPaths:          "max_paths",
	StartingNail:      "starting_nail",
	MinimumDifference: "minimum_difference",
	BrightnessFactor:  "brightness_factor",
	ImageContrast:     "image_contrast",
	PhysicalRadius:    "physical_radius",
	PreviewURL:        "preview_url",
	GcodeURL:          "gcode_url",
	PathlistURL:       "pathlist_url",
	ThreadLength:      "thread_length",
	TotalLines:        "total_lines",
	ErrorMessage:      "error_message",
	CreatedAt:         "created_at",
	UpdatedAt:         "updated_at",
}

var CompositionTableColumns = struct {
	ID                string
	ArtID             string
	Status            string
	NailsQuantity     string
	ImgSize           string
	MaxPaths          string
	StartingNail      string
	MinimumDifference string
	BrightnessFactor  string
	ImageContrast     string
	PhysicalRadius    string
	PreviewURL        string
	GcodeURL          string
	PathlistURL       string
	ThreadLength      string
	TotalLines        string
	ErrorMessage      string
	CreatedAt         string
	UpdatedAt         string
}{
	ID:                "compositions.id",
	ArtID:             "compositions.art_id",
	Status:            "compositions.status",
	NailsQuantity:     "compositions.nails_quantity",
	ImgSize:           "compositions.img_size",
	MaxPaths:          "compositions.max_paths",
	StartingNail:      "compositions.starting_nail",
	MinimumDifference: "compositions.minimum_difference",
	BrightnessFactor:  "compositions.brightness_factor",
	ImageContrast:     "compositions.image_contrast",
	PhysicalRadius:    "compositions.physical_radius",
	PreviewURL:        "compositions.preview_url",
	GcodeURL:          "compositions.gcode_url",
	PathlistURL:       "compositions.pathlist_url",
	ThreadLength:      "compositions.thread_length",
	TotalLines:        "compositions.total_lines",
	ErrorMessage:      "compositions.error_message",
	CreatedAt:         "compositions.created_at",
	UpdatedAt:         "compositions.updated_at",
}

// Generated where

type whereHelperCompositionStatusEnum struct{ field string }

func (w whereHelperCompositionStatusEnum) EQ(x CompositionStatusEnum) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelperCompositionStatusEnum) NEQ(x CompositionStatusEnum) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelperCompositionStatusEnum) LT(x CompositionStatusEnum) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelperCompositionStatusEnum) LTE(x CompositionStatusEnum) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelperCompositionStatusEnum) GT(x CompositionStatusEnum) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelperCompositionStatusEnum) GTE(x CompositionStatusEnum) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelperCompositionStatusEnum) IN(slice []CompositionStatusEnum) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperCompositionStatusEnum) NIN(slice []CompositionStatusEnum) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelperfloat64 struct{ field string }

func (w whereHelperfloat64) EQ(x float64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperfloat64) NEQ(x float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelperfloat64) LT(x float64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperfloat64) LTE(x float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelperfloat64) GT(x float64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperfloat64) GTE(x float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelperfloat64) IN(slice []float64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperfloat64) NIN(slice []float64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var CompositionWhere = struct {
	ID                whereHelperstring
	ArtID             whereHelperstring
	Status            whereHelperCompositionStatusEnum
	NailsQuantity     whereHelperint
	ImgSize           whereHelperint
	MaxPaths          whereHelperint
	StartingNail      whereHelperint
	MinimumDifference whereHelperint
	BrightnessFactor  whereHelperint
	ImageContrast     whereHelperfloat64
	PhysicalRadius    whereHelperfloat64
	PreviewURL        whereHelpernull_String
	GcodeURL          whereHelpernull_String
	PathlistURL       whereHelpernull_String
	ThreadLength      whereHelpernull_Int
	TotalLines        whereHelpernull_Int
	ErrorMessage      whereHelpernull_String
	CreatedAt         whereHelpertime_Time
	UpdatedAt         whereHelpertime_Time
}{
	ID:                whereHelperstring{field: "\"compositions\".\"id\""},
	ArtID:             whereHelperstring{field: "\"compositions\".\"art_id\""},
	Status:            whereHelperCompositionStatusEnum{field: "\"compositions\".\"status\""},
	NailsQuantity:     whereHelperint{field: "\"compositions\".\"nails_quantity\""},
	ImgSize:           whereHelperint{field: "\"compositions\".\"img_size\""},
	MaxPaths:          whereHelperint{field: "\"compositions\".\"max_paths\""},
	StartingNail:      whereHelperint{field: "\"compositions\".\"starting_nail\""},
	MinimumDifference: whereHelperint{field: "\"compositions\".\"minimum_difference\""},
	BrightnessFactor:  whereHelperint{field: "\"compositions\".\"brightness_factor\""},
	ImageContrast:     whereHelperfloat64{field: "\"compositions\".\"image_contrast\""},
	PhysicalRadius:    whereHelperfloat64{field: "\"compositions\".\"physical_radius\""},
	PreviewURL:        whereHelpernull_String{field: "\"compositions\".\"preview_url\""},
	GcodeURL:          whereHelpernull_String{field: "\"compositions\".\"gcode_url\""},
	PathlistURL:       whereHelpernull_String{field: "\"compositions\".\"pathlist_url\""},
	ThreadLength:      whereHelpernull_Int{field: "\"compositions\".\"thread_length\""},
	TotalLines:        whereHelpernull_Int{field: "\"compositions\".\"total_lines\""},
	ErrorMessage:      whereHelpernull_String{field: "\"compositions\".\"error_message\""},
	CreatedAt:         whereHelpertime_Time{field: "\"compositions\".\"created_at\""},
	UpdatedAt:         whereHelpertime_Time{field: "\"compositions\".\"updated_at\""},
}

// CompositionRels is where relationship names are stored.
var CompositionRels = struct {
	Art string
}{
	Art: "Art",
}

// compositionR is where relationships are stored.
type compositionR struct {
	Art *Art `boil:"Art" json:"Art" toml:"Art" yaml:"Art"`
}

// NewStruct creates a new relationship struct
func (*compositionR) NewStruct() *compositionR {
	return &compositionR{}
}

func (r *compositionR) GetArt() *Art {
	if r == nil {
		return nil
	}
	return r.Art
}

// compositionL is where Load methods for each relationship are stored.
type compositionL struct{}

var (
	compositionAllColumns            = []string{"id", "art_id", "status", "nails_quantity", "img_size", "max_paths", "starting_nail", "minimum_difference", "brightness_factor", "image_contrast", "physical_radius", "preview_url", "gcode_url", "pathlist_url", "thread_length", "total_lines", "error_message", "created_at", "updated_at"}
	compositionColumnsWithoutDefault = []string{"art_id"}
	compositionColumnsWithDefault    = []string{"id", "status", "nails_quantity", "img_size", "max_paths", "starting_nail", "minimum_difference", "brightness_factor", "image_contrast", "physical_radius", "preview_url", "gcode_url", "pathlist_url", "thread_length", "total_lines", "error_message", "created_at", "updated_at"}
	compositionPrimaryKeyColumns     = []string{"id"}
	compositionGeneratedColumns      = []string{}
)

type (
	// CompositionSlice is an alias for a slice of pointers to Composition.
	// This should almost always be used instead of []Composition.
	CompositionSlice []*Composition
	// CompositionHook is the signature for custom Composition hook methods
	CompositionHook func(context.Context, boil.ContextExecutor, *Composition) error

	compositionQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	compositionType                 = reflect.TypeOf(&Composition{})
	compositionMapping              = queries.MakeStructMapping(compositionType)
	compositionPrimaryKeyMapping, _ = queries.BindMapping(compositionType, compositionMapping, compositionPrimaryKeyColumns)
	compositionInsertCacheMut       sync.RWMutex
	compositionInsertCache          = make(map[string]insertCache)
	compositionUpdateCacheMut       sync.RWMutex
	compositionUpdateCache          = make(map[string]updateCache)
	compositionUpsertCacheMut       sync.RWMutex
	compositionUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var compositionAfterSelectMu sync.Mutex
var compositionAfterSelectHooks []CompositionHook

var compositionBeforeInsertMu sync.Mutex
var compositionBeforeInsertHooks []CompositionHook
var compositionAfterInsertMu sync.Mutex
var compositionAfterInsertHooks []CompositionHook

var compositionBeforeUpdateMu sync.Mutex
var compositionBeforeUpdateHooks []CompositionHook
var compositionAfterUpdateMu sync.Mutex
var compositionAfterUpdateHooks []CompositionHook

var compositionBeforeDeleteMu sync.Mutex
var compositionBeforeDeleteHooks []CompositionHook
var compositionAfterDeleteMu sync.Mutex
var compositionAfterDeleteHooks []CompositionHook

var compositionBeforeUpsertMu sync.Mutex
var compositionBeforeUpsertHooks []CompositionHook
var compositionAfterUpsertMu sync.Mutex
var compositionAfterUpsertHooks []CompositionHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Composition) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compositionAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Composition) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compositionBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Composition) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compositionAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Composition) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compositionBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Composition) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compositionAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Composition) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compositionBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Composition) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compositionAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Composition) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compositionBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Composition) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compositionAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCompositionHook registers your hook function for all future operations.
func AddCompositionHook(hookPoint boil.HookPoint, compositionHook CompositionHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		compositionAfterSelectMu.Lock()
		compositionAfterSelectHooks = append(compositionAfterSelectHooks, compositionHook)
		compositionAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		compositionBeforeInsertMu.Lock()
		compositionBeforeInsertHooks = append(compositionBeforeInsertHooks, compositionHook)
		compositionBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		compositionAfterInsertMu.Lock()
		compositionAfterInsertHooks = append(compositionAfterInsertHooks, compositionHook)
		compositionAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		compositionBeforeUpdateMu.Lock()
		compositionBeforeUpdateHooks = append(compositionBeforeUpdateHooks, compositionHook)
		compositionBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		compositionAfterUpdateMu.Lock()
		compositionAfterUpdateHooks = append(compositionAfterUpdateHooks, compositionHook)
		compositionAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		compositionBeforeDeleteMu.Lock()
		compositionBeforeDeleteHooks = append(compositionBeforeDeleteHooks, compositionHook)
		compositionBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		compositionAfterDeleteMu.Lock()
		compositionAfterDeleteHooks = append(compositionAfterDeleteHooks, compositionHook)
		compositionAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		compositionBeforeUpsertMu.Lock()
		compositionBeforeUpsertHooks = append(compositionBeforeUpsertHooks, compositionHook)
		compositionBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		compositionAfterUpsertMu.Lock()
		compositionAfterUpsertHooks = append(compositionAfterUpsertHooks, compositionHook)
		compositionAfterUpsertMu.Unlock()
	}
}

// OneG returns a single composition record from the query using the global executor.
func (q compositionQuery) OneG(ctx context.Context) (*Composition, error) {
	return q.One(ctx, boil.GetContextDB())
}

// One returns a single composition record from the query.
func (q compositionQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Composition, error) {
	o := &Composition{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for compositions")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all Composition records from the query using the global executor.
func (q compositionQuery) AllG(ctx context.Context) (CompositionSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// All returns all Composition records from the query.
func (q compositionQuery) All(ctx context.Context, exec boil.ContextExecutor) (CompositionSlice, error) {
	var o []*Composition

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Composition slice")
	}

	if len(compositionAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all Composition records in the query using the global executor
func (q compositionQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// Count returns the count of all Composition records in the query.
func (q compositionQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count compositions rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table using the global executor.
func (q compositionQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// Exists checks if the row exists in the table.
func (q compositionQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if compositions exists")
	}

	return count > 0, nil
}

// Art pointed to by the foreign key.
func (o *Composition) Art(mods ...qm.QueryMod) artQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.ArtID),
	}

	queryMods = append(queryMods, mods...)

	return Arts(queryMods...)
}

// LoadArt allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (compositionL) LoadArt(ctx context.Context, e boil.ContextExecutor, singular bool, maybeComposition interface{}, mods queries.Applicator) error {
	var slice []*Composition
	var object *Composition

	if singular {
		var ok bool
		object, ok = maybeComposition.(*Composition)
		if !ok {
			object = new(Composition)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeComposition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeComposition))
			}
		}
	} else {
		s, ok := maybeComposition.(*[]*Composition)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeComposition)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeComposition))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &compositionR{}
		}
		args[object.ArtID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &compositionR{}
			}

			args[obj.ArtID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`arts`),
		qm.WhereIn(`arts.id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Art")
	}

	var resultSlice []*Art
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Art")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for arts")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for arts")
	}

	if len(artAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Art = foreign
		if foreign.R == nil {
			foreign.R = &artR{}
		}
		foreign.R.Compositions = append(foreign.R.Compositions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ArtID == foreign.ID {
				local.R.Art = foreign
				if foreign.R == nil {
					foreign.R = &artR{}
				}
				foreign.R.Compositions = append(foreign.R.Compositions, local)
				break
			}
		}
	}

	return nil
}

// SetArtG of the composition to the related item.
// Sets o.R.Art to related.
// Adds o to related.R.Compositions.
// Uses the global database handle.
func (o *Composition) SetArtG(ctx context.Context, insert bool, related *Art) error {
	return o.SetArt(ctx, boil.GetContextDB(), insert, related)
}

// SetArt of the composition to the related item.
// Sets o.R.Art to related.
// Adds o to related.R.Compositions.
func (o *Composition) SetArt(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Art) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"compositions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"art_id"}),
		strmangle.WhereClause("\"", "\"", 2, compositionPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ArtID = related.ID
	if o.R == nil {
		o.R = &compositionR{
			Art: related,
		}
	} else {
		o.R.Art = related
	}

	if related.R == nil {
		related.R = &artR{
			Compositions: CompositionSlice{o},
		}
	} else {
		related.R.Compositions = append(related.R.Compositions, o)
	}

	return nil
}

// Compositions retrieves all the records using an executor.
func Compositions(mods ...qm.QueryMod) compositionQuery {
	mods = append(mods, qm.From("\"compositions\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"compositions\".*"})
	}

	return compositionQuery{q}
}

// FindCompositionG retrieves a single record by ID.
func FindCompositionG(ctx context.Context, iD string, selectCols ...string) (*Composition, error) {
	return FindComposition(ctx, boil.GetContextDB(), iD, selectCols...)
}

// FindComposition retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindComposition(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Composition, error) {
	compositionObj := &Composition{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"compositions\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, compositionObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from compositions")
	}

	if err = compositionObj.doAfterSelectHooks(ctx, exec); err != nil {
		return compositionObj, err
	}

	return compositionObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *Composition) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Composition) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no compositions provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(compositionColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	compositionInsertCacheMut.RLock()
	cache, cached := compositionInsertCache[key]
	compositionInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			compositionAllColumns,
			compositionColumnsWithDefault,
			compositionColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(compositionType, compositionMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(compositionType, compositionMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"compositions\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"compositions\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into compositions")
	}

	if !cached {
		compositionInsertCacheMut.Lock()
		compositionInsertCache[key] = cache
		compositionInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// UpdateG a single Composition record using the global executor.
// See Update for more documentation.
func (o *Composition) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// Update uses an executor to update the Composition.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Composition) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	compositionUpdateCacheMut.RLock()
	cache, cached := compositionUpdateCache[key]
	compositionUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			compositionAllColumns,
			compositionPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update compositions, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"compositions\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, compositionPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(compositionType, compositionMapping, append(wl, compositionPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update compositions row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for compositions")
	}

	if !cached {
		compositionUpdateCacheMut.Lock()
		compositionUpdateCache[key] = cache
		compositionUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAllG updates all rows with the specified column values.
func (q compositionQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values.
func (q compositionQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for compositions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for compositions")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o CompositionSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CompositionSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), compositionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"compositions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, compositionPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in composition slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all composition")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *Composition) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Composition) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("models: no compositions provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(compositionColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	compositionUpsertCacheMut.RLock()
	cache, cached := compositionUpsertCache[key]
	compositionUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			compositionAllColumns,
			compositionColumnsWithDefault,
			compositionColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			compositionAllColumns,
			compositionPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert compositions, could not build update column list")
		}

		ret := strmangle.SetComplement(compositionAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(compositionPrimaryKeyColumns) == 0 {
				return errors.New("models: unable to upsert compositions, could not build conflict column list")
			}

			conflict = make([]string, len(compositionPrimaryKeyColumns))
			copy(conflict, compositionPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"compositions\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(compositionType, compositionMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(compositionType, compositionMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert compositions")
	}

	if !cached {
		compositionUpsertCacheMut.Lock()
		compositionUpsertCache[key] = cache
		compositionUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// DeleteG deletes a single Composition record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *Composition) DeleteG(ctx context.Context) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB())
}

// Delete deletes a single Composition record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Composition) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Composition provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), compositionPrimaryKeyMapping)
	sql := "DELETE FROM \"compositions\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from compositions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for compositions")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

func (q compositionQuery) DeleteAllG(ctx context.Context) (int64, error) {
	return q.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all matching rows.
func (q compositionQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no compositionQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from compositions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for compositions")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o CompositionSlice) DeleteAllG(ctx context.Context) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CompositionSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(compositionBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), compositionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"compositions\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, compositionPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from composition slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for compositions")
	}

	if len(compositionAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *Composition) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: no Composition provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Composition) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindComposition(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CompositionSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: empty CompositionSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CompositionSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CompositionSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), compositionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"compositions\".* FROM \"compositions\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, compositionPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in CompositionSlice")
	}

	*o = slice

	return nil
}

// CompositionExistsG checks if the Composition row exists.
func CompositionExistsG(ctx context.Context, iD string) (bool, error) {
	return CompositionExists(ctx, boil.GetContextDB(), iD)
}

// CompositionExists checks if the Composition row exists.
func CompositionExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"compositions\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if compositions exists")
	}

	return exists, nil
}

// Exists checks if the Composition row exists.
func (o *Composition) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return CompositionExists(ctx, exec, o.ID)
}
